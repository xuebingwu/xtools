#include <string>
#include <sstream>
#include <iostream>
#include <fstream>
#include <vector>
#include <set>
#include <map>
#include <iomanip>
#include <array>        // std::array

#include <boost/regex.hpp>

// for position matrix
#include <boost/numeric/ublas/matrix.hpp>

#include <stdio.h>
#include <stdlib.h>
#include <algorithm>
#include "stat.h"

#include "utility.h"
#include "tabtools.h"

extern "C"{
#include "ushuffle.h"
}

using namespace std;



// PKA: remove overlapping motifs
// input: all significant motifs
int non_overlapping_sig_motifs(string inputfile, string outputfile);

// count substring in a map of sequences, i.e. from fasta
// used in generating markov model
int countSubstringInSeqs(map<string,string>seqs, string sub);


set<int> findall(string seq, string motif);

// dict for IUPAC degenerate nucleotides
map<char,string> define_IUPAC();


// generate all possible combinations of letters in alphabet of fixed length k, i.e. kmer
vector<string> generate_kmers(int k, string alphabet);

// degenerate kmers based on IUPAC, DNA only
// remove those with terminal N, which is not a kmer, but (k-i)mer
vector<string> degenerate_kmer(int k);

// convert one degenerate kmer to regular expression, e.g. ARG -> A[AG]G
string degenerate_kmer_to_regex(string kmer,map<char,string> iupac);

// expand a degenerate kmer to all possible exact kmers
vector<string> expand_degenerate_kmer(string seq, map<char,string> iupac);

// implant a motif to a set of sequences
// motif can contain degenerate nucleotides
void implant_motif(map<string,string> &seqs, int position, string motif, double fraction);


// write pwm in meme format
void write_pwm_in_meme_format(boost::numeric::ublas::matrix<double> pwm, string motifname, string filename);


// build position weight matrix for a positional kmer, can include flanking sequence
boost::numeric::ublas::matrix<double> create_position_weight_matrix_from_kmer(map<string,string> seqs, string kmer, int position, map<char,string> iupac, int d, int startPos);

//PKA : create logo for a single kmer
void create_logo_for_kmer(map<string,string> seqs, string kmer, int position, map<char,string> iupac, int d, int startPos,string output);

// create logos for top 1 kmer passing pCutoff_B
void create_logo_for_topN_sig_kmer_per_position(map<string,string> seqs, string filename,int d, double pCutoff_B,int startPos,string output);


vector<int> count_one_kmer_in_all_seqs_regex(map<string,string> seqs, boost::regex pattern, int k, int seq_len_minus_k_plus_1, int k_plus_shift);



// doesn't work with shift+degenerate
// for each kmer, count its freq at each position(start), allowing shifts (to the right)
map<string,vector<int> > count_all_kmer_in_seqs(vector<string> kmers, map<string,string> seqs, int shift);  

//PKA
void print_kmer_positional_profile(map<string,vector<int> > data);


map<string,vector<int> > degenerate_kmer_counts(vector<string> dkmers,map<string,vector<int> > data, map<char,string> define_iupac);

array<int,2> find_significant_kmer_from_one_seq_set(map<string,string>seqs1, map<string,double> probs_kmer,vector<string>kmers, vector<string> dkmers, int shift,bool degenerate,double pCutoff, double pCutoff_B, int startPos,int nTest, string outfile, string output_count_file);

// two file comparison, not allow shift and degenerate at the same time
array<int,2> find_significant_kmer_from_two_seq_sets(map<string,string>seqs1, map<string,string>seqs2, vector<string>kmers, vector<string> dkmers, int shift,bool degenerate,double pCutoff,double pCutoff_B, double pseudo,int startPos,int nTest, string outfile,string output_count_file);


void plot_frequency_for_significant_kmer(string inputfile, string outputfile);
   


string StringToUpper(string strToConvert);

char complement(char ch);

string reverseComplement(string seq);

void ReadOneSeqFromFasta(ifstream& infile, string& name, string& seq);

map<string,string> ReadFasta(string filename);

void WriteFasta(map<string,string> seqs, string filename);


//uShuffle
//http://digital.cs.usu.edu/~mjiang/ushuffle/
// shuffle sequence preserving k-let
string shuffle_seq_preserving_k_let(string str,int k);

//
map<string,string> shuffle_seqs_preserving_k_let(map<string,string> seqs, int N, int k);

map<string,string> first_n_bases(map<string,string> seqs,int n);

map<string,string> last_n_bases(map<string,string> seqs,int n);


void mismatches(map<string,string>& mutant,map<string,int>& dist, string motif, int n, set<char> alphabet);

map<string,string> ExpandMotifs(map<string,string>& motifs, int nmismatch, bool rc, set<char> alphabet) ;


int* match(string motiffile, string seqfile, string outfile, int nmismatch, bool rc, set<char> alphabet);



int tab2bed_galaxy(string infile, string outfile);


int tab2bed_bedtools(string infile, string outfile);

